												
#version 330																				
																									
in vec4  vColor; 	
in vec2 texCoord;	
in vec3 Normal;	
in vec3 FragPos;																

out vec4 color;		


struct DirectionalLight {
    vec3 color;
    float ambientIntensity;
	
	vec3 direction; //the position of the light. the guy in the tutorial was not completely correct on the idea behind this
	float diffuseIntensity;
};	

struct Material {
	
	float specularIntensity;
	float shininess;

};

uniform DirectionalLight directionalLight;	
uniform Material material;
uniform sampler2D sampler;
uniform vec3 cameraPos;
																
																									
void main () {			
		
	vec3 lightDir = normalize(directionalLight.direction - FragPos);//a vector from frag position to the light source
	vec3 eyeDir = normalize( cameraPos - FragPos);	//a vector from frag position to camera
	vec3 norm = normalize(Normal); //absolutely neccesary.
	
	
	
	//There is a bit more to these calculations that Ben Cook missed ... >.>
	
    //ambient
    vec4 ambientColor = vec4(directionalLight.color, 1.0f) * directionalLight.ambientIntensity;	
	
	//diffusion	
    float diffusionFactor = max(dot(norm, lightDir), 0.0f);	
	vec4 diffuseColor = vec4(directionalLight.color, 1.0f) * directionalLight.diffuseIntensity * diffusionFactor;
	
	//specular
	vec3 reflectRay = normalize(reflect(-lightDir, norm));
	float spec = pow(max(dot(eyeDir, reflectRay), 0.0f),32);
	vec4 specularColor = vec4(0.0f);
	
	
	//if we dont get any diffusion, meaning the light is behind the object then we couldn't possibly get a specular.
	if ( diffusionFactor > 0.0f ) { 
		specularColor = vec4(directionalLight.color, 1.0f) * material.specularIntensity * spec * material.shininess;
	}
	
	
	//output
	color = texture(sampler, texCoord) * (ambientColor + diffuseColor + specularColor);		
	
	
}